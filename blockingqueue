import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.lang.ref.WeakReference;
import java.util.AbstractQueue;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;
import java.util.function.Predicate;

public class ArrayBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {
    private static final long serialVersionUID = -817911632652898426L;
    final Object[] items;
    int takeIndex;
    int putIndex;
    int count;
    final ReentrantLock lock;
    private final Condition notEmpty;
    private final Condition notFull;
    transient ArrayBlockingQueue<E>.Itrs itrs;

    static final int inc(int i, int modulus) {
        ++i;
        if (i >= modulus) {
            i = 0;
        }

        return i;
    }

    static final int dec(int i, int modulus) {
        --i;
        if (i < 0) {
            i = modulus - 1;
        }

        return i;
    }

    final E itemAt(int i) {
        return this.items[i];
    }

    static <E> E itemAt(Object[] items, int i) {
        return items[i];
    }

    private void enqueue(E e) {
        Object[] items = this.items;
        items[this.putIndex] = e;
        if (++this.putIndex == items.length) {
            this.putIndex = 0;
        }

        ++this.count;
        this.notEmpty.signal();
    }

    private E dequeue() {
        Object[] items = this.items;
        E e = items[this.takeIndex];
        items[this.takeIndex] = null;
        if (++this.takeIndex == items.length) {
            this.takeIndex = 0;
        }

        --this.count;
        if (this.itrs != null) {
            this.itrs.elementDequeued();
        }

        this.notFull.signal();
        return e;
    }

    void removeAt(int removeIndex) {
        Object[] items = this.items;
        if (removeIndex == this.takeIndex) {
            items[this.takeIndex] = null;
            if (++this.takeIndex == items.length) {
                this.takeIndex = 0;
            }

            --this.count;
            if (this.itrs != null) {
                this.itrs.elementDequeued();
            }
        } else {
            int i = removeIndex;
            int putIndex = this.putIndex;

            while(true) {
                int pred = i++;
                if (i == items.length) {
                    i = 0;
                }

                if (i == putIndex) {
                    items[pred] = null;
                    this.putIndex = pred;
                    --this.count;
                    if (this.itrs != null) {
                        this.itrs.removedAt(removeIndex);
                    }
                    break;
                }

                items[pred] = items[i];
            }
        }

        this.notFull.signal();
    }
